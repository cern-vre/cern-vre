apiVersion: helm.toolkit.fluxcd.io/v2beta1
kind: HelmRelease
metadata:
  name: daskhub
  namespace: daskhub
  annotations:
    flux.weave.works/automated: "false" 
   
spec:
  releaseName: dask
  interval: 5m
  chart:
    spec:
      sourceRef:
        kind: HelmRepository
        name: daskhub-charts
        namespace: daskhub
      interval: 1m
      chart: daskhub
      version: 2023.1.0

#   # valuesFrom:
#   #   - kind: Secret
#   #     name: daskhub
#   #     valuesKey: values.yaml

  values:
    # DaskHub configuration values
    # ----------------------------
    rbac:
      enabled: true  # Create and use roles and service accounts on an RBAC-enabled cluster.

    jupyterhub:
      proxy:
        # run only on master nodes
        chp:
            nodeSelector:
                  node-role.kubernetes.io/master: ""
            tolerations:
                - key: "node-role.kubernetes.io/master"
                  operator: Exists
      hub:
        # run only on master nodes
        nodeSelector:
              node-role.kubernetes.io/master: ""
        tolerations:
            - key: "node-role.kubernetes.io/master"
              operator: Exists
        db:
          type: sqlite-memory
          upgrade: true
        services:
          dask-gateway:
            apiToken: "bdd355fa21a11309d4c78bb0ad4c7358a282d2756b692b0b3bb4ed242317e45d"
        extraConfig:
          # Register Dask Gateway service and setup singleuser environment.
          00-add-dask-gateway-values: |
            # 1. Sets `DASK_GATEWAY__PROXY_ADDRESS` in the singleuser environment.
            # 2. Adds the URL for the Dask Gateway JupyterHub service.
            import os

            # These are set by jupyterhub.
            release_name = os.environ["HELM_RELEASE_NAME"]
            release_namespace = os.environ["POD_NAMESPACE"]

            if "PROXY_HTTP_SERVICE_HOST" in os.environ:
                # https is enabled, we want to use the internal http service.
                gateway_address = "http://{}:{}/services/dask-gateway/".format(
                    os.environ["PROXY_HTTP_SERVICE_HOST"],
                    os.environ["PROXY_HTTP_SERVICE_PORT"],
                )
                print("Setting DASK_GATEWAY__ADDRESS {} from HTTP service".format(gateway_address))
            else:
                gateway_address = "http://proxy-public/services/dask-gateway"
                print("Setting DASK_GATEWAY__ADDRESS {}".format(gateway_address))

            # Internal address to connect to the Dask Gateway.
            c.KubeSpawner.environment.setdefault("DASK_GATEWAY__ADDRESS", gateway_address)
            # Internal address for the Dask Gateway proxy.
            c.KubeSpawner.environment.setdefault("DASK_GATEWAY__PROXY_ADDRESS", "gateway://traefik-{}-dask-gateway.{}:80".format(release_name, release_namespace))
            # Relative address for the dashboard link.
            c.KubeSpawner.environment.setdefault("DASK_GATEWAY__PUBLIC_ADDRESS", "/services/dask-gateway/")
            # Use JupyterHub to authenticate with Dask Gateway.
            c.KubeSpawner.environment.setdefault("DASK_GATEWAY__AUTH__TYPE", "jupyterhub")

            # Adds Dask Gateway as a JupyterHub service to make the gateway available at
            # {HUB_URL}/services/dask-gateway
            service_url = "http://traefik-{}-dask-gateway.{}".format(release_name, release_namespace)
            for service in c.JupyterHub.services:
                if service["name"] == "dask-gateway":
                    if not service.get("url", None):
                        print("Adding dask-gateway service URL")
                        service.setdefault("url", service_url)
                    break
            else:
                print("dask-gateway service not found. Did you set jupyterhub.hub.services.dask-gateway.apiToken?")

      singleuser:    
        image:
          name: pangeo/base-notebook  # Image to use for singleuser environment. Must include dask-gateway.
          tag: 2021.06.05
        defaultUrl: "/lab"  # Use jupyterlab by defualt.
        memory:
          guarantee: 500M
          limit: 1G
        cpu:
          guarantee: 0.3
          limit: 1
        storage:
          type: none
          
        # storage:
        #   type: dynamic
        #   capacity: 1Gi
        #   dynamic:
        #     storageClass: standard
        # default is 300s, sometimes Jetstream volumes are slow to attach
        startTimeout: 600
        # See https://github.com/zonca/jupyterhub-deploy-kubernetes-jetstream/issues/38
        lifecycleHooks:
          postStart:
            exec:
              command:
                - "sh"
                - "-c"
                - >
                  chmod 700 .ssh;
                  chmod g-s .ssh;
                  chmod 600 .ssh/*;
                  exit 0
      ingress:
        enabled: true
        annotations:
          kubernetes.io/ingress.class: "nginx"
        hosts:
            - nb-vre.cern.ch

    dask-gateway:
      enabled: true  # Enabling dask-gateway will install Dask Gateway as a dependency.
      # Futher Dask Gateway configuration goes here
      # See https://github.com/dask/dask-gateway/blob/master/resources/helm/dask-gateway/values.yaml
      gateway:
        prefix: "/services/dask-gateway"  # Users connect to the Gateway through the JupyterHub service.
        auth:
          type: jupyterhub  # Use JupyterHub to authenticate with Dask Gateway
          jupyterhub:
            apiToken: "bdd355fa21a11309d4c78bb0ad4c7358a282d2756b692b0b3bb4ed242317e45d"
      traefik:
        service:
          type: ClusterIP  # Access Dask Gateway through JupyterHub. To access the Gateway from outside JupyterHub, this must be changed to a `LoadBalancer`.

    dask-kubernetes:
      # Use dask-kubernetes, rather than Dask Gateway, for creating Dask Clusters.
      # Enabling this also requires
      # 1. Setting `jupyterhub.singleuser.serviceAccountName: daskkubernetes`.
      # 2. Ensuring that `dask-kubernetes` is in your singleuser environment.
      enabled: false
              
    # jupyterhub:
    
    #   proxy:  
    #     service:
    #       type: LoadBalancer
    #       # loadBalancerIP: 137.138.6.73 
    #     https:
    #       enabled: true # true
    #       hosts:
    #         - nb-vre.cern.ch
    #       type: secret
    #       secret:
    #         name: cern-sectigo-tls-certificate
    #         namespace: jhub
    #     # secretToken: ###

    #   hub:

    #     services:
    #       dask-gateway: {}
    #         # apiToken: ###
    #     networkPolicy:
    #       enabled: false   
    #     db:
    #       type: sqlite-memory
    #       upgrade: true

    #     config:
    #       GenericOAuthenticator:
    #         client_id: 
    #           valueFrom:
    #             secretKeyRef:
    #               name: jhub-cvre-iam-secrets
    #               namespace: jhub
    #               key: client_id
    #         client_secret: 
    #           valueFrom:
    #             secretKeyRef:
    #               name: jhub-cvre-iam-secrets
    #               namespace: jhub
    #               key: client_secret
    #         oauth_callback_url: https://nb-vre.cern.ch/hub/oauth_callback
    #         authorize_url: https://iam-escape.cloud.cnaf.infn.it/authorize
    #         token_url: https://iam-escape.cloud.cnaf.infn.it/token 
    #         userdata_url: https://iam-escape.cloud.cnaf.infn.it/userinfo
    #         scope:
    #           - openid
    #           - profile
    #           - email
    #           - offline_access
    #         username_key: preferred_username
    #       JupyterHub:
    #           authenticator_class: generic-oauth
    #           # authenticator_class: dummy
    #   singleuser:
    #     storage:
    #       type: none
    #     # image:
    #     #   name: ghcr.io/vre-hub/dask-root  # Image to use for singleuser environment. Must include dask-gateway.
    #     #   tag: "latest"
    #     defaultUrl: "/lab" 

    # dask-gateway:
    #   gateway:
    #     auth:
    #       jupyterhub:
    #         apiTokenFromSecretName: hub
    #         apiTokenFromSecretKey: hub.services.dask-gateway.apiToken
    #         # apiToken: ###
    #   traefik:
    #     service:
    #       type: LoadBalancer
    # dask-kubernetes:
    # #   # Use dask-kubernetes, rather than Dask Gateway, for creating Dask Clusters.
    # #   # Enabling this also requires
    # #   # 1. Setting `jupyterhub.singleuser.serviceAccountName: daskkubernetes`.
    # #   # 2. Ensuring that `dask-kubernetes` is in your singleuser environment.
    #   enabled: true

