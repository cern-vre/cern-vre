hub:
  db:
    type: sqlite-memory # change to postgresql with DBOD from CERN (secret already exists in tf set)
  config:
    RucioAuthenticator:
      # client_id: "" # set through secret
      # client_secret: "" # set through secret
      authorize_url: https://iam-escape.cloud.cnaf.infn.it/authorize
      token_url: https://iam-escape.cloud.cnaf.infn.it/token
      userdata_url: https://iam-escape.cloud.cnaf.infn.it/userinfo
      username_key: preferred_username
      scope:
        - openid
        - profile
        - email
  extraConfig:
    00-first-config: |
      import pprint
      import os
      import warnings
      import requests

      from oauthenticator.generic import GenericOAuthenticator

      class RucioAuthenticator(GenericOAuthenticator):
          def __init__(self, **kwargs):
              super().__init__(**kwargs)
              self.enable_auth_state = True

          def exchange_token(self, token):
              params = {
                  'client_id': self.client_id,
                  'client_secret': self.client_secret,
                  'grant_type': 'urn:ietf:params:oauth:grant-type:token-exchange',
                  'subject_token': token,
                  'scope': 'openid email profile',
                  'audience': 'rucio'
              }
              response = requests.post(self.token_url, data=params)
              refresh_token = response.json()['access_token']
              return refresh_token
          
          async def pre_spawn_start(self, user, spawner):
              auth_state = await user.get_auth_state()
              pprint.pprint(auth_state)
              if not auth_state:
                  # user has no auth state
                  return
              
              # define some environment variables from auth_state
              spawner.environment['ACCESS_TOKEN'] = auth_state['access_token']
              spawner.environment['REFRESH_TOKEN'] = self.exchange_token(auth_state['access_token'])

      c.JupyterHub.authenticator_class = RucioAuthenticator

      # enable authentication state
      c.GenericOAuthenticator.enable_auth_state = True

      if 'JUPYTERHUB_CRYPT_KEY' not in os.environ:
          warnings.warn(
              "Need JUPYTERHUB_CRYPT_KEY env for persistent auth_state.\n"
              "    export JUPYTERHUB_CRYPT_KEY=$(openssl rand -hex 32)"
          )
          c.CryptKeeper.keys = [os.urandom(32)]

singleuser:
  storage:
    type: none
  image:
    name: gitlab-registry.cern.ch/escape-wp2/docker-images/datalake-singleuser # replace with updated image in vre-hub
    tag: latest
    pullPolicy: Always
  cmd: null
  extraEnv:
    RUCIO_MODE: "download"
    RUCIO_WILDCARD_ENABLED: "1"
    RUCIO_BASE_URL: "https://escape-rucio.cern.ch"
    RUCIO_AUTH_URL: "https://escape-rucio-auth.cern.ch"
    RUCIO_DISPLAY_NAME: "VRE-RUCIO"
    RUCIO_NAME: "vre-rucio.cern.ch"
    RUCIO_SITE_NAME: "ROAMING"
    RUCIO_CA_CERT: "/certs/rucio_ca.pem" # set in the gitlab image from the gitlab runner, thus needs to be set in the new image in a different way
    RUCIO_OIDC_AUTH: "env"
    RUCIO_OIDC_ENV_NAME: "REFRESH_TOKEN"
    RUCIO_DEFAULT_AUTH_TYPE: "oidc"
    RUCIO_OAUTH_ID: "rucio"
    RUCIO_DEFAULT_INSTANCE: "vre-rucio.cern.ch"

proxy:
  service:
    type: LoadBalancer
    loadBalancerIP: 137.138.6.77
    annotations:
      loadbalancer.openstack.org/network-id: "798d00f3-2af9-48a0-a7c3-a26d909a2d64"
      service.beta.kubernetes.io/openstack-internal-load-balancer: "true"
      loadbalancer.openstack.org/cascade-delete: "false"
  # https:
  #   enabled: true
  #   hosts:
  #     - jhub-vre.cern.ch # change cert and url later if necessary
  #   letsencrypt: # autoprovisioning of certificate not working
  #     contactEmail: vre-admin@cern.ch
